{% extends "template.html" %}
{% block scripts %}
  <style>
    body {
      background-image: none;
    }
    footer {
      display: none;
    }
  </style>
  <link rel="stylesheet" href="{{ url_for('static', filename='chessboardjs-1.0.0/css/chessboard-1.0.0.css') }}"/>
  <script
    src="https://code.jquery.com/jquery-3.6.0.min.js"
    integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4="
    crossorigin="anonymous"></script>
  <script type="text/javascript" src="{{ url_for('static', filename='chessboardjs-1.0.0/js/chessboard-1.0.0.js') }}"></script>
{% endblock %}
{% block chessboard %}

  <h4 class="fw-bold">AI</h4>

  <div class="centre-board mb-2">
    <div id="myBoard"></div>
  </div>

  {% if current_user.is_anonymous %}
    <h4 class="fw-bold">Player 1</h4>
  {% else %}
    <h4 class="fw-bold">{{ current_user.username }}</h4>
  {% endif %}

  <button type="button" class="btn btn-outline-dark my-2" onClick="window.location.reload();">Play a new game</button>
  <br/>
  <h3 id="winningMethod" class="d-inline"></h3>
  <h3 id="winnerSide" class="d-inline"></h3>

  <script type="text/javascript" charset="utf-8">
    const whiteSquareHighlighted = '#a9a9a9'
    const blackSquareHighlighted = '#3E3524'

    let board = null
    let winner = null
    let checkmate = false
    let draw = false
    let turn = 0
    let legalMoves = {}

    let playerOrientation

    // Picks the side the player will play on
    const playerColour = Math.floor(Math.random() * 2)
    // console.log(playerColour)

    if (playerColour === 0) {
      playerOrientation = 'white'
    } else {
      playerOrientation = 'black'
    }
    // console.log(playerOrientation)

    const displayWinner = (winningMethod) => {
      $('#winningMethod').text(winningMethod + '!')
      if (winner === 0) {
        $('#winnerSide').text('White wins!')
      } else {
        $('#winnerSide').text('Black wins!')
      }
    }

    socket.on('available_moves_response', ({available_moves, position, information}) => {
      board.position(position)

      legalMoves = available_moves

      turn = information['current_turn']
      winner = information['winner']
      checkmate = information['checkmate']
      draw = information['draw']
      // console.log(winner, checkmate, draw)

      if (checkmate) {
        displayWinner('Checkmate', winner)
      } else if (draw) {
        displayWinner('Stalemate', winner)
      } else if (turn !== playerColour) {
        socket.emit('ai_moves', playerColour)
      }

      // console.log('available_moves_response')
    })

    const removeHighlightedSquares = () => {
      $('#myBoard .square-55d63').css('background', '')
    }

    const highlightSquare = (square) => {
      let $square = $('#myBoard .square-' + square)

      let background = whiteSquareHighlighted
      if ($square.hasClass('black-3c85d')) {
        background = blackSquareHighlighted
      }

      $square.css('background', background)
    }

    const onDragStart = (source, piece, position, orientation) => { // console.log('onDragStart') console.log(piece) do not pick up pieces if the game is over
      if (winner != null || checkmate || draw) {
        return false
      }

      // only allow to pick up piece if it's the player's turn
      if (turn !== playerColour) {
        return false
      }

      // only pick up pieces for the side to move
      if ((playerColour === 0 && piece.search(/^b/) !== -1) || (playerColour === 1 && piece.search(/^w/) !== -1)) {
        return false
      }
    }

    const onDrop = (source, target) => {
      // console.log('onDrop')

      // gets the coordinate part of the string
      const onlyLegalCoordinates = legalMoves[source].map((v) => v.slice(0, 2))

      const indexOfMove = onlyLegalCoordinates.indexOf(target)

      // only place if move is legal
      if (indexOfMove === -1) {
        return 'snapback'
      } else { // joins the string variable source with the square and special move its moving to console.log('emit available_moves')
        socket.emit('available_moves', source.concat(legalMoves[source][indexOfMove]))
      } onMouseoutSquare()
    }

    const onMouseoverSquare = (square, piece) => {
      // console.log('onMouseoverSquare')

      // do not pick highlight pieces if the game is over
      if (winner != null || checkmate || draw) {
        return
      }

      if (! legalMoves[square]) {
        return
      }

      // only highlight if it's the player's turn
      if (turn !== playerColour) {
        return
      }

      // only highlight the player's pieces
      if ((playerColour === 0 && piece.search(/^b/) !== -1) || (playerColour === 1 && piece.search(/^w/) !== -1)) {
        return
      }

      // gets the coordinate part of the string
      const onlyLegalMoves = legalMoves[square].map((v) => v.slice(0, 2))

      // exit if theres are no moves available for this square
      if (onlyLegalMoves.length === 0) {
        return
      }
      // highlight the square they moused over
      highlightSquare(square)

      // highlight the possible squares for this piece
      for (let i = 0; i < onlyLegalMoves.length; i++) {
        highlightSquare(onlyLegalMoves[i])
      }
    }

    const onMouseoutSquare = (square, piece) => {
      console.log('onMouseoutSquare')
      removeHighlightedSquares()
    }

    const config = {
      draggable: true,
      orientation: playerOrientation,
      position: 'start',
      onDragStart: onDragStart,
      onDrop: onDrop,
      onMouseoutSquare: onMouseoutSquare,
      onMouseoverSquare: onMouseoverSquare
    }
    board = Chessboard('myBoard', config)

    board.resize()

    if (playerColour === 0) {
      socket.emit('available_moves')
    } else {
      socket.emit('ai_moves', playerColour)
    }

    window.addEventListener('resize', (event) => {
      board.resize()
    }, true)
  </script>
{% endblock %}
